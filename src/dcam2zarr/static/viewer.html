<!DOCTYPE html>
<html>
<head>
    <title>DCAM Live Viewer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #1e1e1e;
            color: #fff;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .controls {
            background: #2d2d2d;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .controls label {
            margin-right: 10px;
        }
        .controls input, .controls button {
            margin: 5px;
            padding: 5px 10px;
        }
        canvas {
            border: 1px solid #444;
            max-width: 100%;
            background: #000;
        }
        .stats {
            margin-top: 10px;
            font-family: monospace;
            font-size: 12px;
            background: #2d2d2d;
            padding: 10px;
            border-radius: 5px;
        }
        .error {
            color: #ff4444;
            padding: 10px;
            background: #2d2d2d;
            border-radius: 5px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>DCAM Live Viewer</h1>
        
        <div class="controls">
            <label>
                Update Interval (ms):
                <input type="number" id="interval" value="100" min="10" max="5000">
            </label>
            
            <label>
                <input type="checkbox" id="autoScale"> Auto Scale
            </label>
            
            <label>
                Min: <input type="number" id="vmin" value="0" style="width: 80px;">
            </label>
            <label>
                Max: <input type="number" id="vmax" value="65535" style="width: 80px;">
            </label>
            
            <button id="startBtn">Start</button>
            <button id="stopBtn" disabled>Stop</button>
            
            <hr>
            
            <label>
                <input type="checkbox" id="roiEnabled"> Enable ROI
            </label>
            <label>
                X: <input type="number" id="roiX" value="0" style="width: 60px;">
            </label>
            <label>
                Y: <input type="number" id="roiY" value="0" style="width: 60px;">
            </label>
            <label>
                W: <input type="number" id="roiW" value="256" style="width: 60px;">
            </label>
            <label>
                H: <input type="number" id="roiH" value="256" style="width: 60px;">
            </label>
        </div>
        
        <div id="error" class="error" style="display: none;"></div>
        
        <canvas id="canvas"></canvas>
        
        <div class="stats" id="stats">
            Waiting for frames...
        </div>
    </div>

    <script>
        const API_URL = 'http://localhost:8080';
        
        let animationId = null;
        let frameCount = 0;
        let lastFrameNumber = -1;
        let startTime = null;
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const stats = document.getElementById('stats');
        const errorDiv = document.getElementById('error');
        
        const intervalInput = document.getElementById('interval');
        const autoScaleCheckbox = document.getElementById('autoScale');
        const vminInput = document.getElementById('vmin');
        const vmaxInput = document.getElementById('vmax');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        
        const roiEnabled = document.getElementById('roiEnabled');
        const roiX = document.getElementById('roiX');
        const roiY = document.getElementById('roiY');
        const roiW = document.getElementById('roiW');
        const roiH = document.getElementById('roiH');
        
        function showError(msg) {
            errorDiv.textContent = msg;
            errorDiv.style.display = 'block';
        }
        
        function hideError() {
            errorDiv.style.display = 'none';
        }
        
        async function fetchFrame() {
            const url = new URL(`${API_URL}/latest`);
            
            if (roiEnabled.checked) {
                url.searchParams.set('x', roiX.value);
                url.searchParams.set('y', roiY.value);
                url.searchParams.set('w', roiW.value);
                url.searchParams.set('h', roiH.value);
            }
            
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const metadata = {
                frameNumber: parseInt(response.headers.get('X-Frame-Number')),
                timestamp: parseFloat(response.headers.get('X-Timestamp')),
                shape: response.headers.get('X-Frame-Shape').split(',').map(Number),
                dtype: response.headers.get('X-Frame-Dtype')
            };
            
            const buffer = await response.arrayBuffer();
            
            // Parse based on dtype (assuming uint16 for now)
            let data;
            if (metadata.dtype === 'uint16') {
                data = new Uint16Array(buffer);
            } else if (metadata.dtype === 'uint8') {
                data = new Uint8Array(buffer);
            } else {
                throw new Error(`Unsupported dtype: ${metadata.dtype}`);
            }
            
            return { data, metadata };
        }

        function arrayMin(arr) {
            let min = arr[0];
            for (let i = 1; i < arr.length; i++) {
                if (arr[i] < min) min = arr[i];
            }
            return min;
        }

        function arrayMax(arr) {
            let max = arr[0];
            for (let i = 1; i < arr.length; i++) {
                if (arr[i] > max) max = arr[i];
            }
            return max;
        }

        function renderFrame(frameData, metadata) {
            const [height, width] = metadata.shape;
            const data = frameData;
            
            // Resize canvas if needed
            if (canvas.width !== width || canvas.height !== height) {
                canvas.width = width;
                canvas.height = height;
            }
            
            // Calculate min/max for scaling
            let min, max;
            if (autoScaleCheckbox.checked) {
                min = arrayMin(data);
                max = arrayMax(data);
            } else {
                min = parseFloat(vminInput.value);
                max = parseFloat(vmaxInput.value);
            }
            
            // Convert to 8-bit grayscale
            const imageData = ctx.createImageData(width, height);
            const range = max - min || 1;
            
            for (let i = 0; i < data.length; i++) {
                const normalized = Math.min(255, Math.max(0, 
                    ((data[i] - min) / range) * 255));
                const pixelIndex = i * 4;
                imageData.data[pixelIndex] = normalized;     // R
                imageData.data[pixelIndex + 1] = normalized; // G
                imageData.data[pixelIndex + 2] = normalized; // B
                imageData.data[pixelIndex + 3] = 255;        // A
            }
            window.requestAnimationFrame(() => {
                ctx.putImageData(imageData, 0, 0);
            });
            
            // Update stats
            const actualMin = arrayMin(data);
            const actualMax = arrayMax(data);
            const mean = data.reduce((a, b) => a + b, 0) / data.length;
            const elapsed = (Date.now() - startTime) / 1000;
            const fps = frameCount / elapsed;
            
            stats.innerHTML = `
                Frame: ${metadata.frameNumber} | 
                Time: ${metadata.timestamp.toFixed(3)}s | 
                Shape: ${metadata.shape.join('Ã—')} | 
                Min/Max: ${actualMin}/${actualMax} | 
                Mean: ${mean.toFixed(1)} | 
                Display FPS: ${fps.toFixed(1)}
            `;
        }
        
        async function updateLoop() {
            try {
                hideError();
                
                const { data, metadata } = await fetchFrame();
                
                // Only render if we got a new frame
                if (metadata.frameNumber !== lastFrameNumber) {
                    lastFrameNumber = metadata.frameNumber;
                    frameCount++;
                    renderFrame(data, metadata);
                }
                
                // Schedule next update
                const interval = parseInt(intervalInput.value);
                animationId = setTimeout(updateLoop, interval);
                
            } catch (error) {
                console.error('Error fetching frame:', error);
                showError(`Error: ${error.message}`);
                
                // Retry after interval
                const interval = parseInt(intervalInput.value);
                animationId = setTimeout(updateLoop, interval);
            }
        }
        
        function start() {
            if (animationId !== null) return;
            
            startTime = Date.now();
            frameCount = 0;
            lastFrameNumber = -1;
            
            startBtn.disabled = true;
            stopBtn.disabled = false;
            
            updateLoop();
        }
        
        function stop() {
            if (animationId !== null) {
                clearTimeout(animationId);
                animationId = null;
            }
            
            startBtn.disabled = false;
            stopBtn.disabled = true;
        }
        
        startBtn.addEventListener('click', start);
        stopBtn.addEventListener('click', stop);
        
        // Auto-start
        start();
    </script>
</body>
</html>